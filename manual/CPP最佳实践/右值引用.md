1. 什么是左值、右值

   - **有地址**的变量是左值：可以通过& 取地址，位于等号左边；

   - **没有地址**的临时值、字面值是右值：不能通过&取地址，位于等号右边，是临时值；

     ```
     // a 可以用&取地址，且位于=左边
     // 5 不能用&去地址，且位于=右边
     int a = 5;
     ```

2. 什么是左值引用、右值引用

   引用的本质是别名，可以用过引用修改变量的值，传参数传引用可以避免拷贝，其原理与指针类似；

   - 左值引用：能指向左值，不能指向右值

   - const左值引用：不会修改指向值，**既可以指向左值，也可以指向右值**；

     ```c++
     int a = 5;
     int &ref_a = a;// ref_a 是左值引用
     int &ref_a = 5;// 右值没有地址，没法被修改，所以左值引用没法指向右值
     const int &ref_a =5;// const左值引用不会修改指向值，因此可以指向右值；
     // std::vector中的void push_back (const value_type& val);
     // 如果函数参数没有const，则vec.push_back(5)没法通过编译;
     ```

   - 右值引用：专门为右值设计，不能指向左值，可以通过std::move()转换指向左值，指向右值，**可以用来修改右值**；

     ```c++
     int &&ref_right = 5;
     int a = 5;
     int &&ref_left = a;//编译不通过，右值引用没法指向左值
     ref_right = 6;//右值引用可以用来修改右值，这有啥用？？？
     ```

   - **右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值**

     - 被声明出来的右值引用、左值引用都是左值；因为有地址，且位于等号左边；

   - 右值引用的优势：

     - 作为函数参数时，右值引用更灵活，**既可以接受左值也可以接受右值，并且可以对参数进行修改**；const左值引用也可以接受左值和右值，但是不能修改；

       ```c++
       void f(const int& n) {
           n += 1; // 编译失败，const左值引用不能修改指向变量
       }
       
       void f2(int && n) {
           n += 1; // ok
       }
       
       int main() {
           f(5);
           f2(5);
       }
       ```

       

3. std::move  ： 将左值转换为右值，让右值引用可以指向左值，为什么需要？

   - std::move 并不是把一个变量的内容移动到了另一个变量（因此不会提升性能），只是把左值转换为右值，让**右值引用可以指向左值**；

     ```c++
     int a = 5;
     int &&ref_right = std::move(a);
     ```
     

4. 总结：

   - **从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。**
   - **右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。**
   - **作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。**

5. 右值引用和std::move的应用场景

   - 实现移动语义：
     - 定义类时，实现移动构造函数和移动赋值操作符，避免深度拷贝，提升性能；
     - 本质上被拷贝的数据进行了移动，被拷贝的数据需要置空；

6. std::forward 完美转发

   - std::forward 并没有做转发，只是做了类型转换，既可以转换为左值，也可以转换为右值

   