1. 对象的初始化方式

   - 4种初始化方式

     ```cpp
     int gemfield = 7030;
     int gemfield(7030);
     int gemfield = {7030};
     int gemfield{7030};
     ```

   - 基础类型如果没有像上面这样使用四种方式显式进行初始化的话，那么就会：

     - 如果定义在函数外，那么会被默认初始化为0；
     - 如果定义在函数内，则默认初始化为undefined值；

2. 构造函数；

   - **默认构造函数与合成默认构造函数**

     - 没有参数的构造函数叫做**默认构造函数**（default constructor），如果一个类没有定义任何构造函数，那么编译器会自动生成一个，称之为**合成默认构造函数**（synthesized default constructor）。**一旦类中用户显式的定义了任何的构造函数，那么编译器将停止自动生成默认构造函数。**
     - 默认构造函数在很多场景下都会被用到（比如：定义一个局部对象却没有使用initializer的时候；作为别的类的成员而该类又有默认构造函数的时候，等等），因此，**设计一个类的最佳实践之一就是：总是为该class设计一个默认构造函数**。

   - **用户定义的构造函数**

     - 在进入用户定义的构造函数体之前，类的成员已经被初始化过一遍了，使用的正是如下的三种方式之一（三选一）：

       - default initialize；

       - in-class initializer；

       - constructor initializer list；

         而一旦进入构造函数体之后，再想修改该类的成员，就只能使用assign operator了。

     - 什么情况下**只能**使用**构造函数初始化列表**（constructor initializer list）来对类的成员进行初始化呢？以下四种情况：

       - 成员是const类型；
       - 成员是引用类型；
       - 成员的类型没有定义默认构造函数；
       - 追求构造效率的；

     - **代理构造函数（delegating constructor）**

     - **转换构造函数（Converting constructors）**

       - 当构造函数可以使用一个参数进行调用的时候，这个构造函数就是**转换构造函数（Converting constructors）**。构造函数可以使用一个参数进行调用意味着以下两种情况：

         - 构造函数只有一个参数；

         - 构造函数有多个参数，但除了第一个外都有默认值；

       - 转换构造函数实际上相是一个隐式类型转换；
       - 同时只能进行一种转换构造；
       - 如果我想禁用转换构造函数（Converting constructors），那该怎么办呢？使用**explicit**关键字修饰转换构造函数的声明；explicit只用于转换构造函数才生效，用于其他构造函数没有意义；

     - **继承构造函数（inherit constructor）**

       ```text
       class D : public B{
           public:
               using B::B;
       };
       ```

       使用using关键字来复用基类的构造函数，称之为继承构造函数（inherit constructor）。通过使用using关键字，我们将基类class B中的**所有的构造函数**都以如下的形式在子类class D中重新定义了一遍：

       ```text
       D(params) : B(args) {};
       ```

       

1. 拷贝构造函数、赋值运算符；

   - **拷贝构造函数**

     如果**构造函数**的第一个参数是该类的引用类型，并且其它参数都有默认值，那么这个构造函数就是**拷贝构造函数（copy constructor）**。只要用户不自定义拷贝构造函数，编译器就会自动合成。合成拷贝构造函数的特点就是，它会执行对象之间的**memberwise copy**来进行对象的拷贝构造。拷贝构造函数在多个场景下都会用到：

     - **拷贝初始化（Copy initialization）**，使用一个对象初始化另一个对象的时候，比如：

     ```text
     A a1 = a2;
     ```

     注意，一定要和赋值运算符区分开来。等号左边是未初始化的对象时，这是拷贝构造；如果是已经初始化过（包括默认初始化），则是赋值运算符，比如下面这样就是赋值运算符：

     ```text
     A a1;
     
     //a1已经默认初始化了
     a1 = a2;
     ```

     - 函数调用时候的传参（形参类型不是引用），也就是传值的时候会调用拷贝构造函数。这个很有趣，也解释了**为什么拷贝构造函数的参数必须是引用类型**。假设拷贝构造函数的参数类型不是引用而是传值，那么传值就要调用拷贝构造函数，这就变成了鸡生蛋和蛋生鸡的问题了。
     - 接收返回值，且返回值类型不是引用的时候；
     - 使用大括号初始化数组里的元素、aggregate class的成员的时候；

     注意，在标准库的容器添加元素的时候，insert、push等是copy initialization，而emplace操作是直接初始化。

   - ​	**赋值运算符**

     这个和拷贝构造函数类似，值得说的地方有3处（以编译器自动合成的赋值运算符为例）：

     - 为了和内置类型的行为一致，赋值运算符的返回值为等号左边操作符的引用；
     - 参数不一定要为引用类型，因为没有鸡生蛋的问题；但最好是reference to const类型；
     - 如果成员是数组类型，数组中的每个元素都会被赋值操作；

     为什么叫赋值运算符而不是赋值构造函数呢？因为构造函数是没有返回值的，而赋值运算符是有返回值的。返回值的类型最好是non-const reference，并且指向等号左边的对象。为什么呢？假设返回的是void或者其它类型，那么对于 a = b = c这样的表达式怎么办呢？哈哈哈哈。

     实践中一定要注意对参数进行检查，防止自己赋值给自己的情况发生。

2. 移动构造函数、移动赋值运算符；

3. 析构函数；

   构造函数的函数体是在成员都初始化完毕之后再执行的，与之相反，析构函数则是在函数体执行完毕再开始销毁类的成员的。

4. 继承体系；

5. Rule of Three/Five；

   理解了类中资源的管理，你就会得出如下结论：

   - 如果该类显式的定义了析构函数，则一般也需要显式的定义拷贝构造函数、赋值运算符（除非使用=delete直接禁止该类的拷贝和赋值）；
   - 如果该类显式的定义了拷贝构造函数，则也需要显式的定义赋值运算符；反之亦然；
   - 我们应该把拷贝构造、赋值运算符、移动构造、移动赋值运算符、析构函数看成一个整体，如果用户定义了其中一个，就应该定义所有的；

   这就是C++11之前的Rule of Three，以及C++11之后的Rule of Five。

6. 访问控制；

7. 传值和传引用；

8. const语义；

9. 智能指针作为类的成员；

   对于[类的成员函数](https://www.zhihu.com/search?q=类的成员函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"271732707"})来说（好吧，也适用于[非成员函数](https://www.zhihu.com/search?q=非成员函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"271732707"})），使用智能指针的一些实践原则如下所示：

   - 如果在函数中返回的资源想要由调用者管理的话，返回unique_ptr，调用者之后可以自己再自由发挥，比如可以把它赋给shared_ptr（如果想要的话）；
   - 从函数中返回shared_ptr相对比较少，如果出现这种情况，那意思就是：函数的设计者想要延长该函数中创建的资源的生命周期；
   - 从函数中很少返回weak_ptr，从调用者角度来看的话，如果调用者无从知晓返回的对象是否还在其生命周期中，则可以考虑使用weak_ptr；
   - 如果从函数中返回的资源的生命周期并不由调用者介入或者管理，并且也管理不了，那么函数返回裸指针或者引用。

10. 异常处理；

11. 标准库使用；

12. 模板设计模式；

13. 线程安全及可重入；