在图形学中，矩阵的乘法顺序取决于**坐标系的表示方式**和**矩阵的存储方式**。以下是关键点总结：

---

### **1. 列向量 vs 行向量**
- **列向量（Column Vector）**：
  - **变换顺序**：矩阵按 **右乘（Right-to-Left）** 顺序组合。
  - **公式**：最终变换矩阵 \( M = T \times R \times S \)，变换应用顺序为 **缩放（S）→ 旋转（R）→ 平移（T）**。
  - **示例**：OpenGL、Vulkan 默认使用列向量。
  - **数学表示**：
    \[
    P' = M \times P = T \times R \times S \times P
    \]

- **行向量（Row Vector）**：
  - **变换顺序**：矩阵按 **左乘（Left-to-Right）** 顺序组合。
  - **公式**：最终变换矩阵 \( M = S \times R \times T \)，变换应用顺序为 **平移（T）→ 旋转（R）→ 缩放（S）**。
  - **示例**：DirectX 默认使用行向量。
  - **数学表示**：
    \[
    P' = P \times M = P \times S \times R \times T
    \]

---

### **2. 矩阵存储方式**
- **列主序（Column-Major）**：
  - 矩阵按列存储在内存中，OpenGL 使用此格式。
  - **匹配列向量**：自然支持右乘顺序，变换矩阵按 `T * R * S` 组合。

- **行主序（Row-Major）**：
  - 矩阵按行存储在内存中，DirectX 使用此格式。
  - **匹配行向量**：自然支持左乘顺序，变换矩阵按 `S * R * T` 组合。

---

### **3. 实际应用中的组合顺序**
#### **示例：先缩放（S）、再旋转（R）、最后平移（T）**
- **列向量（右乘）**：
  \[
  M = T \times R \times S \quad \Rightarrow \quad P' = T \times R \times S \times P
  \]
  - **效果**：顶点先缩放，再旋转，最后平移。

- **行向量（左乘）**：
  \[
  M = S \times R \times T \quad \Rightarrow \quad P' = P \times S \times R \times T
  \]
  - **效果**：顶点先平移，再旋转，最后缩放。

---

### **4. 常见图形 API 的默认行为**
| **API/框架** | **向量类型** | **矩阵存储** | **乘法顺序** | **示例组合**                  |
| ------------ | ------------ | ------------ | ------------ | ----------------------------- |
| **OpenGL**   | 列向量       | 列主序       | 右乘         | \( M = T \times R \times S \) |
| **Vulkan**   | 列向量       | 列主序       | 右乘         | \( M = T \times R \times S \) |
| **DirectX**  | 行向量       | 行主序       | 左乘         | \( M = S \times R \times T \) |
| **Unity**    | 列向量       | 列主序       | 右乘         | \( M = T \times R \times S \) |
| **Unreal**   | 行向量       | 行主序       | 左乘         | \( M = S \times R \times T \) |

---

### **5. 为什么会有这种差异？**
- **数学习惯**：线性代数中通常使用列向量和右乘。
- **API 设计**：DirectX 为了与 Windows 行主序内存布局兼容，选择行向量和左乘。

---

### **6. 总结**
- **列向量系统**：矩阵按 **右乘（Right-to-Left）** 顺序组合，先应用的变换在右侧。
- **行向量系统**：矩阵按 **左乘（Left-to-Right）** 顺序组合，先应用的变换在左侧。
- **核心原则**：矩阵乘法顺序需与坐标系和存储方式匹配，确保变换按预期顺序应用。

理解这一点对正确实现模型变换、视图变换和投影变换至关重要。