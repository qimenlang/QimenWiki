#### 纹理采样

1. 步骤

   - 获取两个最近的mipmap

   - 分别对两个mipmap进行双线性插值（bilinear interpolation），得到两个插值结果
     1. 双线性插值：先在水平方向进行两次线性插值，然后在垂直方向（或者先垂直再水平）对前两次插值的结果再进行一次线性插值

   - 对两个插值结果进行线性插值

2. 以上步骤，一共采样了8个像素点，进行了7次插值；



#### 游戏渲染基础

1. GPU硬件架构
   - SIMD (Single Instruction Multiple Data):单指令多数据：一条指令同时处理多个数据相同的运算；
     - 具体同时计算几个数据，取决于 **SIMD寄存器位宽 (bits) / 单个数据元素位宽 (bits)**
     - Vec4 做一次加法，xyzw同时运算；
     - C++ SIMD指令集扩展： **SSE (Streaming SIMD Extensions)**
     
   - SIMT(Single Instruction Multiple Threads)：单指令多线程：一条指令可以在N个核上并行处理N个数据的同样的运算操作，是GPU的并行执行模型
   
     - 硬件层：将多个线程（通常是32个，称为一个warp）捆绑在一起，执行同一条指令
     - 软件层：编写单一线程的代码，硬件自动将其复制到多个线程上并行执行；
   
   - GPU 费米架构
   
     - GPC（Graphics Processing Cluster）：图形处理集群
       - 多个SM
       - 光栅引擎：光栅化操作
       - 多边形引擎
       - GPC缓存、内存接口
     - SM（Streaming Multiprocessor）：流式多处理器，包含以下部件
       - 32个CUDA Core
       - 线程调度器
       - 共享内存、L1缓存、寄存器
       - 纹理单元：从纹理内存中采样并过滤
     - CUDA Core ： 执行单个线程的实际算术和逻辑运算
   
   - 数据从CPU到GPU的传输是性能瓶颈
   
     - 因该瓶颈的存在，尽量只做CPU到GPU的单向数据传输，GPU只管绘制不管逻辑
   
     ![](images/dataFromCpu2Gpu.png)
   
   - 缓存 ：数据如果放在缓存中，需要尽量放在一起，并且不能太大；
   
     - Cache Hit : 数据在缓存中
     - Cache Miss ：数组不在缓存中
   
   - 手机的GPU架构：Tile-Base Rendering ,划分成多个瓦片分别进行渲染；
   
     - 主要用于解决传统**立即模式渲染**在内存带宽的瓶颈，尤其应用于移动设备
     
     - GPU的on-chip memory/Tile Memory 刚好能够容纳一个瓦片的颜色、深度、模板等数据
     
     - 受益于 Tile 内完整的深度信息，可以提前进行深度测试（Early-Z）和隐藏面消除（HSR）
       - 隐藏面消除（HSR：Hidden Surface Removal）：在片段着色之前，丢弃所有被遮挡的片段；
       
         - 通过维护深度缓冲区，保证每个像素位置只计算和保留深度最小的片段；
         - 原理：三角形光栅化之后，拿到片段的深度，与深度缓冲对比，小于则执行片段着色并更新深度缓冲；大于则不执行片段着色，避免overdraw;
       
       - 提前深度测试(Early-Z)：
       
         - 传统的图形管线中，深度测试（Z-Test）是在片元着色器（Fragment Shader）**之后**进行的,**Early-Z** 将深度测试尽可能**提前**到片元着色器**之前**执行，对光栅化生成的片段进行深度测试；从而尽早丢弃那些注定不可见的片元,避免OverDraw
       
       - **提前深度测试**是深度缓冲算法在现代GPU上高效实现**隐藏面消除**的核心机制
       
         
   
2. 可渲染物体

   - submesh：根据mesh所用的材质的不同，将mesh切分成多个submesh;
   - 多个相同的mesh怎么绘制：Use Handles to Reuse Resources;
   - GPU绘制时，把相同材质的mesh放到一起绘制；
   - GPU Batch Rendering：渲染物体时，一次性设置一堆一模一样的物体的VB、IB和其位移数据，然后一个draw call指令，将所有设置的物体全部绘制出来，提高效率；

3. 可见性裁剪

   - 使用包围盒做裁剪，判断包围盒是否在视锥体中；

     <img src="C:\Users\51039\AppData\Roaming\Typora\typora-user-images\image-20220520124220989.png" alt="image-20220520124220989" style="zoom:67%;" />

   - BVH (Bounding Volume Hierarchy) Culling

     <img src="C:\Users\51039\AppData\Roaming\Typora\typora-user-images\image-20220520124503475.png" alt="image-20220520124503475" style="zoom:67%;" />

   - Early-Z : 先在GPU中绘制场景的深度图，根据深度图确定fragment绘制与否；

4. 纹理压缩

5. 引擎pipeline

   - **Cluster-Based Mesh Pipeline : 当前模型渲染管线的发展方向**

     - 核心思想：对于非常精细的模型，将模型分成小的cluster（meshlet），每个cluster有32/64个三角形；  

     - 在裁剪时，可以按照cluster进行裁剪，其他的渲染管线都是按照物体进行裁剪；

     - 虚幻引擎的Nanite应用了该技术；

       <img src="C:\Users\51039\AppData\Roaming\Typora\typora-user-images\image-20220520132145787.png" alt="image-20220520132145787" style="zoom:50%;" />

   - 可编程渲染管线：

     <img src="C:\Users\51039\AppData\Roaming\Typora\typora-user-images\image-20220520131924986.png" alt="image-20220520131924986" style="zoom: 50%;" />

#### 材质、Shader、光照

1. PBR
   - SG
   - MR
2. Shader 排列
3. 光照
   - 点光源、方向光
   - IBL
   - 全局光照

#### 特殊渲染

1. 地形
2. 天空
3. 后处理

#### 渲染管线

1. 前向渲染、延迟渲染、forward+
2. 基于瓦片的渲染



**MipMap采样的耗费，需要采样8个点，进行7次插值运算；**
