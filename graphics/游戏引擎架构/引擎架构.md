## Game Loop

```c++
    // 1. 处理输入
    HandleInput();

    // 2. 更新逻辑
    Update(deltaTime);

    // 3. 渲染前准备
    PreRender();

    // 4. 渲染
    Render();

    // 5. 渲染后处理
    PostRender();

    // 6. 控制帧率
    ControlFrameRate();
```

### **1. 输入处理（Handle Events）**

- **作用**：处理玩家的输入事件（键盘、鼠标、手柄、触摸等）。
- **关键操作**：
  - **轮询输入设备**：获取当前帧的输入状态。
  - **事件队列处理**：处理窗口事件（如窗口大小变化、退出事件）。

### **2. 更新逻辑（Update Logic）**

- **作用**：更新游戏对象的状态（位置、动画、AI等）。
- **子步骤**：
  - **定时器更新**：计算上一帧的时间差（`deltaTime`）。
  - **游戏逻辑更新**：调用所有游戏对象的 `Update(deltaTime)` 方法。
  - **物理模拟**：运行物理引擎（如 Box2D、PhysX）的 `Step` 方法。
  - **动画系统更新**：驱动骨骼动画或材质动画。
  - **AI 决策**：更新 NPC 的行为树或状态机。

### **3. 渲染前准备（Pre-Render）**

- **作用**：为渲染阶段准备数据，优化渲染性能。
- **子步骤**：
  - **视锥剔除（Frustum Culling）**：剔除视锥外的物体。
  - **渲染排序**：按材质/距离排序对象，减少 GPU 状态切换。
  - **LOD 选择**：根据距离切换模型的细节层级。
  - **资源加载检查**：异步加载未完成的纹理或模型。

### **4. 渲染（Render Pass）**

- **作用**：生成当前帧的图像。
- **子步骤**：
  - **清空缓冲区**：清除颜色、深度和模板缓冲区。
  - **阴影渲染（Shadow Pass）**：生成阴影贴图。
  - **几何渲染（Geometry Pass）**：绘制不透明物体到 G-Buffer（延迟渲染）或直接绘制（前向渲染）。
  - **光照计算**：在延迟渲染中计算光照贡献。
  - **透明物体渲染**：按从后到前顺序绘制透明物体（需混合）。
  - **后处理（Post-Processing）**：应用抗锯齿（AA）、Bloom、色调映射等效果。

### **5. 渲染后处理（Post-Render）**

- **作用**：完成渲染后的资源管理和数据提交。
- **子步骤**：
  - **交换缓冲区**：将后处理结果提交到显示缓冲区。
  - **GPU 资源回收**：释放临时分配的渲染目标或 GPU 资源。
  - **调试信息绘制**：显示帧率、调试文本或线框（需在交换缓冲区前完成）。

### **6. 音频处理（Audio Update）**

- **作用**：更新音效和背景音乐。
- **关键操作**：
  - **播放/停止音效**：根据游戏事件触发声音。
  - **3D 音效更新**：根据声源和听者位置调整音量/方向。

### **7. 网络同步（Network Sync）**

- **作用**：同步多人游戏中的状态。
- **子步骤**：
  - **发送数据**：将本地的玩家操作发送到服务器。
  - **接收数据**：处理服务器发来的其他玩家状态。
  - **插值/预测**：平滑其他玩家的移动（如插值算法）。

### **8. 帧率控制（Frame Rate Control）**

- **作用**：维持稳定的帧率，避免 CPU/GPU 过载。
- **关键操作**：
  - **垂直同步（VSync）**：同步显示刷新率，避免画面撕裂。
  - **帧时间限制**：通过 `SDL_Delay` 或 `std::this_thread::sleep_for` 控制帧率。



### **优化与高级技术**

1. **多线程渲染**：将物理、动画或资源加载放到独立线程。
2. **ECS 架构**：通过实体-组件-系统分离逻辑和渲染。
3. **GPU 异步计算**：使用 Compute Shader 并行处理粒子或后处理。
4. **帧分析工具**：使用 RenderDoc 或 NVIDIA Nsight 分析性能瓶颈。

